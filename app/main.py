from typing import Annotated
from fastapi import Depends, FastAPI, Form, HTTPException, Security, status
from fastapi.security import (
    OAuth2PasswordBearer,
    OAuth2PasswordRequestForm,
    SecurityScopes,
)
from pydantic import BaseModel
from contextlib import asynccontextmanager
import app.auth as auth


@asynccontextmanager
async def lifespan(app: FastAPI):
    auth.update_private_key()
    auth.update_public_key()
    await auth.pool.open()
    yield

    await auth.pool.close()


oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="token",
    scopes={
        "basic": "Basic access, allow for creation of your own scopes and access",
        "admin": "Can disable or delete BASIC users, scopes, and access",
        "CHAD": "Can do literally anything",
        "unobtainable_scope": "useful for testing a scope which nobody should have access to",
    },
)  # use token authentication

tags_metadata = [
    {
        "name": "users",
        "description": "Passkeys are autogenerated by the server for security reasons, grab yourself a token from the /token endpoint to start accessing some endpoints!",
    },
    {
        "name": "scopes",
        "description": "Scope defines an authorization for a user",
    },
    {
        "name": "access",
        "description": "Access defines a scope a user has access to",
    },
]

app = FastAPI(lifespan=lifespan, title="AuthWolfey", openapi_tags=tags_metadata)

RESERVED_SCOPES = ["admin", "CHAD"]


def verify_user(token: Annotated[str, Depends(oauth2_scheme)]):
    try:
        user = auth.verify_token(token)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e),
            headers={"WWW-Authenticate": "Bearer"},
        )

    return user


def authorize_user(
    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
):
    try:
        user = auth.authorize_token(token, security_scopes.scopes)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e),
            headers={"WWW-Authenticate": "Bearer"},
        )

    return user


StrForm = Annotated[str, Form()]
BoolForm = Annotated[bool, Form()]

UserDep = Annotated[auth.User, Depends(verify_user)]
BasicAuthDep = Annotated[auth.User, Security(authorize_user, scopes=["basic"])]
AdminDep = Annotated[auth.User, Security(authorize_user, scopes=["admin"])]
CHADep = Annotated[auth.User, Security(authorize_user, scopes=["CHAD"])]


class Token(BaseModel):
    access_token: str
    token_type: str


def filterize(to_filterize: str):
    return f"%{to_filterize.lower()}%"


@app.post("/token", tags=["users"])
async def create_token(form: Annotated[OAuth2PasswordRequestForm, Depends()]):
    login_result = await auth.login(form.username, form.password, form.scopes)
    if not isinstance(login_result, str):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=login_result.name,
            headers={"WWW-Authenticate": "Bearer"},
        )
    return Token(access_token=login_result, token_type="bearer")


@app.post("/users", status_code=status.HTTP_201_CREATED, tags=["users"])
async def create_user(new_user_name: StrForm, user: AdminDep):
    key = await auth.create_user(new_user_name)
    return {"user": new_user_name, "key": key, "caller": user.username}


@app.get("/users/me", tags=["users"])
def read_me(user: UserDep):
    return user


class UserInfo(BaseModel):
    username: str
    disabled: bool


@app.get("/users/{username}", response_model=UserInfo, tags=["users"])
async def read_user(username: str, user: BasicAuthDep):
    res = await auth.read_user(username)
    if res is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail=f"{username} not found"
        )
    return UserInfo(username=res.name, disabled=res.disabled)


@app.get("/users", response_model=list[str], tags=["users"])
async def read_users(
    user: BasicAuthDep, username_filter: str = "", disabled: bool = False
):
    username_filter = filterize(username_filter)
    users = await auth.filter_user(username_filter, disabled)
    return users


@app.put("/users", tags=["users"])
async def update_user_disabled(username: StrForm, disabled: BoolForm, user: AdminDep):
    subject_is_admin = await auth.check_access(username, "admin")
    if subject_is_admin and not user.is_chad():
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"{user.username} must be a CHAD disable {username}",
        )
    try:
        await auth.set_disabled_user(username, disabled)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )

    return {"user": username, "disabled": disabled, "caller": user.username}


@app.delete("/users", tags=["users"])
async def delete_user(user_to_delete: StrForm, user: AdminDep):
    if not (
        user_to_delete == user.username
        or user.is_chad()
        or (
            user.is_admin()
            and await auth.has_any_scopes(user_to_delete, ["admin", "CHAD"])
        )
    ):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You do not have permission to delete this user",
        )
    try:
        await auth.delete_user(user_to_delete)
    except:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )

    return {"user": user_to_delete, "caller": user.username}


@app.post("/scopes", status_code=status.HTTP_201_CREATED, tags=["scopes"])
async def create_scope(name: StrForm, user: AdminDep):
    try:
        await auth.create_scope(name, user.username)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=str(e),
        )

    return {"scope": name, "caller": user.username}


class ScopeList(BaseModel):
    name: list[str]
    owner: list[str]


@app.get("/scopes", response_model=ScopeList, tags=["scopes"])
async def read_scopes(user: BasicAuthDep, scope: str = "", owner: str = ""):
    scope = filterize(scope)
    owner = filterize(owner)
    scopes = await auth.filter_scope(name=scope, owner=owner)
    names = [scope[0] for scope in scopes]
    owner = [scope[1] for scope in scopes]
    return ScopeList(name=names, owner=owner)


@app.delete("/scopes", tags=["scopes"])
async def delete_scope(scope: StrForm, user: AdminDep):
    owner = await auth.read_scope_owner(scope)
    if owner != user.username and not user.is_chad():
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You must be the owner or a CHAD to delete this scope",
        )
    try:
        await auth.delete_scope(scope)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=str(e),
        )

    return {"scope": scope, "caller": user.username}


@app.post("/access", status_code=status.HTTP_201_CREATED, tags=["access"])
async def create_access(username: StrForm, scope: StrForm, user: AdminDep):
    if scope in RESERVED_SCOPES and not user.is_chad():
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Only CHADs can create admins or CHADs",
        )
    try:
        await auth.create_access(username, scope)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=str(e),
        )
    return {
        "scope": scope,
        "new_user": username,
        "caller": user.username,
    }


class AccessList(BaseModel):
    users: list[str]
    scopes: list[str]


@app.get("/access", response_model=AccessList, tags=["access"])
async def read_access(
    user: BasicAuthDep, user_filter: str = "", scope_filter: str = ""
):
    user_filter = filterize(user_filter)
    scope_filter = filterize(scope_filter)
    access = await auth.filter_access(username=user_filter, scopename=scope_filter)
    users = [access[0] for access in access]
    scopes = [access[1] for access in access]
    return AccessList(users=users, scopes=scopes)


@app.delete("/access", tags=["access"])
async def delete_access(username: StrForm, scope: StrForm, user: AdminDep):
    is_subject_admin = await auth.check_access(username, "admin")
    if is_subject_admin and not user.is_chad():
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only CHADs can delete admin access",
        )
    try:
        await auth.delete_access(user=username, scope=scope)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )

    return {"user": username, "scope": scope, "caller": user.username}
