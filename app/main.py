from typing import Annotated
from fastapi import Depends, FastAPI, Form, HTTPException, Security, status
from fastapi.security import (
    OAuth2PasswordBearer,
    OAuth2PasswordRequestForm,
    SecurityScopes,
)
from pydantic import BaseModel
from contextlib import asynccontextmanager
import app.auth as auth


@asynccontextmanager
async def lifespan(app: FastAPI):
    auth.update_private_key()
    auth.update_public_key()
    await auth.pool.open()
    yield

    await auth.pool.close()


oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="token",
    scopes={
        "basic": "Basic access, allow for creation of your own scopes and access",
        "admin": "Can disable or delete BASIC clients, scopes, and access",
        "CHAD": "Can do literally anything",
        "unobtainable_scope": "useful for testing a scope which nobody should have access to",
    },
)  # use token authentication

tags_metadata = [
    {
        "name": "clients",
        "description": "Passkeys are autogenerated by the server for security reasons, grab yourself a token from the /token endpoint to start accessing some endpoints!",
    },
    {
        "name": "scopes",
        "description": "Scope defines an authorization for a client",
    },
    {
        "name": "access",
        "description": "Access defines a scope a client has access to",
    },
]

app = FastAPI(lifespan=lifespan, title="AuthWolfey", openapi_tags=tags_metadata)

RESERVED_SCOPES = ["admin", "CHAD"]


def authorize_client(
    security_scopes: SecurityScopes, token: Annotated[str, Depends(oauth2_scheme)]
):
    try:
        client = auth.authorize_token(token, security_scopes.scopes)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e),
            headers={"WWW-Authenticate": "Bearer"},
        )

    return client


async def try_edit_user(sub: str, admin: auth.client):
    subject_is_admin = await auth.check_access(sub, "admin")
    if subject_is_admin and not admin.is_chad():
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"{admin.clientname} must be a CHAD disable {sub}",
        )


StrForm = Annotated[str, Form()]
BoolForm = Annotated[bool, Form()]

BasicAuthDep = Annotated[auth.client, Security(authorize_client, scopes=["basic"])]
AdminDep = Annotated[auth.client, Security(authorize_client, scopes=["admin"])]
CHADep = Annotated[auth.client, Security(authorize_client, scopes=["CHAD"])]


class Token(BaseModel):
    access_token: str
    token_type: str


@app.post("/token", tags=["clients"])
async def create_token(form: Annotated[OAuth2PasswordRequestForm, Depends()]):
    login_result = await auth.login(form.username, form.password, form.scopes)
    if not isinstance(login_result, str):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=login_result.name,
            headers={"WWW-Authenticate": "Bearer"},
        )
    return Token(access_token=login_result, token_type="bearer")


@app.post("/clients", status_code=status.HTTP_201_CREATED, tags=["clients"])
async def create_client(new_client_name: StrForm, client: AdminDep):
    try:
        key = await auth.create_client(new_client_name)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=str(e))
    return {"client": new_client_name, "key": key, "caller": client.clientname}


@app.get("/clients/me", tags=["clients"])
def read_me(client: BasicAuthDep):
    return client


class clientInfo(BaseModel):
    clientname: str
    disabled: bool


@app.get("/clients/{clientname}", response_model=clientInfo, tags=["clients"])
async def read_client(clientname: str, client: BasicAuthDep):
    res = await auth.read_client(clientname)
    if res is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail=f"{clientname} not found"
        )
    return clientInfo(clientname=res.name, disabled=res.disabled)


@app.get("/clients", response_model=list[str], tags=["clients"])
async def read_clients(
    client: BasicAuthDep, clientname_filter: str = "", disabled: bool = False
):
    clients = await auth.filter_client(clientname_filter, disabled)
    return clients


@app.put("/clients/{clientname}/disable", tags=["clients"])
async def update_client_disabled(subject: str, disabled: BoolForm, admin: AdminDep):
    await try_edit_user(subject, admin)
    try:
        await auth.set_disabled_client(subject, disabled)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )

    return {"subject": subject, "disabled": disabled, "caller": admin.clientname}


@app.put("/clients/{clientname}/resetkey", tags=["clients"])
async def update_client_key(sub: str, admin: AdminDep):
    await try_edit_user(sub, admin)
    try:
        key = await auth.reset_client_key(sub)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
    return key


@app.delete("/clients", tags=["clients"])
async def delete_client(sub: StrForm, admin: AdminDep):
    await try_edit_user(sub, admin)
    try:
        await auth.delete_client(sub)
    except:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="client not found"
        )

    return {"client": sub, "caller": admin.clientname}


@app.post("/scopes", status_code=status.HTTP_201_CREATED, tags=["scopes"])
async def create_scope(name: StrForm, admin: AdminDep):
    try:
        await auth.create_scope(name, admin.clientname)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=str(e),
        )

    return {"scope": name, "caller": admin.clientname}


@app.get("/scopes", response_model=auth.ScopesList, tags=["scopes"])
async def read_scopes(
    client: BasicAuthDep, scope_filter: str = "", owner_filter: str = ""
):
    return await auth.filter_scope(scope_filter, owner_filter)


@app.delete("/scopes", tags=["scopes"])
async def delete_scope(scope: StrForm, client: AdminDep):
    owner = await auth.read_scope_owner(scope)
    if owner != client.clientname and not client.is_chad():
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You must be the owner or a CHAD to delete this scope",
        )
    try:
        await auth.delete_scope(scope)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=str(e),
        )

    return {"scope": scope, "caller": client.clientname}


@app.post("/access", status_code=status.HTTP_201_CREATED, tags=["access"])
async def create_access(clientname: StrForm, scope: StrForm, client: AdminDep):
    if scope in RESERVED_SCOPES and not client.is_chad():
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=f"Only CHADs can create admins or CHADs",
        )
    try:
        await auth.create_access(clientname, scope)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail=str(e),
        )
    return {
        "scope": scope,
        "new_client": clientname,
        "caller": client.clientname,
    }


@app.get("/access", response_model=auth.AccessList, tags=["access"])
async def read_access(
    client: BasicAuthDep, client_filter: str = "", scope_filter: str = ""
):
    return await auth.filter_access(client_filter, scope_filter)


@app.delete("/access", tags=["access"])
async def delete_access(clientname: StrForm, scope: StrForm, client: AdminDep):
    is_subject_admin = await auth.check_access(clientname, "admin")
    if is_subject_admin and not client.is_chad():
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Only CHADs can delete admin access",
        )
    try:
        await auth.delete_access(client=clientname, scope=scope)
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=str(e),
        )

    return {"client": clientname, "scope": scope, "caller": client.clientname}
